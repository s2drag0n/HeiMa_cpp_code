#include <iostream>
using namespace std;

/*
* 除面向对象外，另一种编程思想叫泛型编程，主要技术是模板
* C++提供两种模板机制：函数模板和类模板
* 
* 函数模板：建立一个通用函数，其函数返回值和形参类型可以不具体指定，用一个虚拟的类型来表示
* 
* 语法
*	template <typename T>		其中typename可以替换为class
*	函数声明和定义
*
* 例子
*	template <typename T>
*	void swap(T& a, T& b){}
* 
* 两种方式使用函数模板
*	1.自动类型推导，直接使用		swap(a, b);
*	2.显式指定类型				swap<int>(a, b);
* 
* 函数模板注意事项
*	1.自动类型推导，必须要推导出一致的数据类型T才能使用
*	2.模板必须要确定出T的数据类型，才可以使用，不能不使用T且不指定
* 
* 普通函数和函数模板的区别
*	1.普通函数调用时，可以发生自动类型转换（隐式）
*		隐式类型转换：int myAdd();	int a;	char c;	可以运行myADD(a, c)
*	2.函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换
*	3.如果利用显式指定类型，会发生隐式类型转换
* 
* 普通函数和函数模板的调用规则
*	1.优先调用普通函数，如果普通函数没有实现，则报错
*	2.通过空模板参数列表强制调用函数模板	myADD<>(a, c);
*	3.函数模板可以重载
*	4.如果函数模板可以产生更好的匹配，则有限调用函数模板	char a;	char b;	myADD(a, b);此时调用的是函数模板
* 
* 模板的局限性
*	使用模板函数重载，实现特定数据类型的特定操作，比如类的相加+、对比==（也可以使用运算符重载）
*	template<T> boolmyCompare(T& a, T& b){}
*	template<> boolmyCompare(Person& a, Person& b){}
* 
* 学习模板不是为了写模板，而是为了在STL中使用系统提供的模板
*/

int main() {

	//函数模板案例：排序算法

	return 0;
}