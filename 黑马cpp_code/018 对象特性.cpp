#include <iostream>
using namespace std;

/*
* 对象的初始化和清理：如果不提供构造和析构，编译器会自动提供空实现
*	构造函数可以重载
*	析构函数没有参数，不能重载
* 
* 构造函数分类
*	有参构造和无参构造
*	普通构造和拷贝构造：Person(const Person& p){}
* 
* 构造函数调用
*	默认构造：Person p;调用默认构造时不要使用()，否则Person()会被当成函数声明
*	括号法：Person p(10);
*	显式法：	Person p = Person(10);
*			Person(10)叫做匿名对象，执行完当前行就会被析构；
*			不要使用拷贝构造函数初始化匿名对象，Person(p2)会认为是对象声明Person p2；
*	隐式转换法：person p = 10；person p = p2；
* 
* 拷贝构造函数调用时机
*	1.旧对象初始化新对象
*	2.值传递的方式给函数参数传值
*	3.以值方式返回局部对象
* 
* 构造函数调用规则
*	默认情况下，编译器提供3个函数给一个类
*		1.默认构造函数（无参，函数体为空）
*		2.默认析构函数（无参，函数体为空）
*		3.默认拷贝构造函数，拷贝属性值
*	构造函数调用规则如下
*		1.如果用户定义了有参构造函数，c++将不再提供无参构造函数，但会提供默认拷贝构造函数
*		2.如果用户定义了拷贝构造函数，c++将不再提供构造函数
* 
* 浅拷贝：简单的赋值拷贝，但会导致堆区的内存重复释放
* 深拷贝：在堆区重新申请空间，进行拷贝操作
* 
* 初始化列表：
*	构造函数():属性(1),属性(2),属性(3),属性(4),...,属性5){}
*	构造函数(a,b,c,d,...,e):属性(a),属性(b),属性(c),属性(d),...,属性(e){}
* 
* 类对象作为类成员：先构造对象成员，先析构外面的对象，即与构造顺序相反
* 
* 静态成员：成员变量或成员函数前加上static关键字
*	静态成员变量：
*		1.所有成员共享一份数据
*		2.在编译阶段分配内存（全局区）
*		3.必须要类内声明，类外初始化 int Person::m_a = 10;
*		4.通过对象或者类名访问静态成员变量Person::m_a
*	静态成员函数
*		1.所有对象共享一个函数
*		2.静态成员函数只能访问静态成员变量，因为无法区分是哪一个对象的变量
*		3.同样的两种访问方式
* 
* 类内成员变量和成员函数分别存储
*	1.c++空对象占用1个字节是为了区分空对象占内存的位置，每个空对象的内存地址应该是独一无二的
*	2.如果对象中有一个int a，则此对象占用4个字节，说明成员变量是属于类的对象上，但静态成员变量不属于类的对象上
*	3.非静态成员函数也不属于类的对象上（内存中只有一份），静态成员函数也不属于类的对象上
* 
* this指针：指向被调用成员函数所属的对象，隐含在每一个非静态成员函数内
*	1.当形参和成员变量同名时，使用this区分
*	2.在类的非静态成员函数中返回对象自身时，使用return *this;
* 
* 空指针访问成员函数：Person p = NULL;
*	如果遇到this指针（使用到了成员变量，此时是一个空对象，无法访问属于类对象的值），需要加以判断if(this == null)	return;
*	
* const 修饰成员函数：void showPerson() cosnt{}
*	1.称之为常函数
*	2.不可以修改成员属性，相当于将Person * const this;修改为了const Person * const this;
*	3.当定义成员属性时声明mutable时，在常函数中依旧可以修改，常对象下也可以改
* 
* const 声明对象：const Person p;
*	1.称之为常对象
*	3.不能修改成员属性
*	2.常对象只能调用常函数
* 
* 友元：让一个函数或者类访问另一个类的私有成员
* 三种实现
*	1.全局函数作为友元：在类的最上方加入friend void func();即可
*	2.成员函数作为友元：在类的最上方加入friend void Goodgay::func();即可
*	3.类作为友元：在类的最上方加入friend class Goodgay;即可
*/

int main() {

	cout << double(8/1.5) << endl;

	return 0;
}


